import sys
sys.path.append('../or-tools-6.7.2-customized/ortools/gen')

from ortools.constraint_solver import pywrapcp
from ast import literal_eval

# Construct solvers for instances generated by the RBGenerator

solverTimeLimit = 100 * 1000    # Search time limit in ms
solverNodeLimit = 5 * 10000
useTimeLimit = False

'''
Parse a txt file generated by RBGenerator, create and return the constraint solver
'''
def constructSolver(caseID, caseFilePath, masterDRL):
    print(caseFilePath);
    caseFile=open(caseFilePath,"r");
    lines=caseFile.readlines();

    # Read head
    paramValues=lines[1].split('\t')
    n = int(paramValues[0]);
    d = int(paramValues[1]);
    m = int(paramValues[2]);
    k = int(paramValues[3]);
    nb = int(paramValues[4]);

    # Create solver
    solver = pywrapcp.Solver("Rand CSP Problem "+caseFilePath)

    # Information recorder - for the RL
    constrList = []
    varConstr = []
    constrVar = []

    # Create variables
    varList = [solver.IntVar(0, d-1, "x%i" % i) for i in range (n)];
    for i in range(len(varList)):
        varConstr.append([])

    # Add constraints
    for i in range(m):
        constrStrings=lines[i+3].split('|')
        scope=literal_eval(constrStrings[0])
        allowedTuples=literal_eval(constrStrings[1])
        tmpConstr=solver.AllowedAssignments(tuple(varList[j] for j in scope), allowedTuples)
        solver.Add(tmpConstr)
        constrList.append(tmpConstr)
        # Record the constrVar and varConstr relations
        for j in scope:
            varConstr[j].append(i)
        constrVar.append(list(scope))

    solver.setVarConstrList(varList, constrList);

    # Config the constrStruct
    if (solver.checkIfCaseInPool(masterDRL,caseID)):
        solver.setConstrStruct(solver.retrieveConstrStruct(masterDRL, caseID));
    else:
        caseConstrStruct=solver.CreateConstrStruct(caseID, varConstr, constrVar);
        solver.setConstrStruct(caseConstrStruct);
        solver.addConstrStructToPool(masterDRL, caseID, caseConstrStruct);

    # print("Solver constructed.\n")
    return solver, varList


def constructSolver_WarmUp(caseID, caseFilePath, masterDRL):
    solver, varList = constructSolver(caseID, caseFilePath, masterDRL)
    db = solver.Phase(varList, solver.CHOOSE_MIN_Q, solver.ASSIGN_MIN_VALUE)
    searchLimit = solver.TimeLimit(solverTimeLimit) if useTimeLimit else solver.BranchesLimit(solverNodeLimit)
    solver.NewSearch(db, searchLimit)
    solver.setMasterDRL(masterDRL)
    solver.setSolverPhase(solver.WARM_UP);
    print("Warm up solver constructed.")
    return solver, varList, searchLimit


def constructSolver_Training(caseID, caseFilePath, masterDRL):
    solver, varList = constructSolver(caseID, caseFilePath, masterDRL)
    db = solver.Phase(varList, solver.CHOOSE_MIN_Q, solver.ASSIGN_MIN_VALUE)
    searchLimit = solver.TimeLimit(solverTimeLimit) if useTimeLimit else solver.BranchesLimit(solverNodeLimit)
    solver.NewSearch(db, searchLimit)
    solver.setMasterDRL(masterDRL)
    solver.setSolverPhase(solver.TRAINING);
    print("Training solver constructed.")
    return solver, varList, searchLimit


def constructSolver_Testing(caseID, caseFilePath, masterDRL):
    solver, varList = constructSolver(caseID, caseFilePath, masterDRL)
    db = solver.Phase(varList, solver.CHOOSE_MIN_Q_TEST, solver.ASSIGN_MIN_VALUE)
    searchLimit = solver.TimeLimit(solverTimeLimit) if useTimeLimit else solver.BranchesLimit(solverNodeLimit)
    solver.NewSearch(db, searchLimit)
    solver.setMasterDRL(masterDRL)
    solver.setSolverPhase(solver.TESTING);
    print("Testing solver constructed.")
    return solver, varList, searchLimit


def constructSolver_Baseline(caseID, caseFilePath, masterDRL, baselineID):
    solver, varList = constructSolver(caseID, caseFilePath, masterDRL)

    if (baselineID == 0):  # CHOOSE_MIN_SIZE
        db = solver.Phase(varList, solver.CHOOSE_MIN_SIZE, solver.ASSIGN_MIN_VALUE);
    elif (baselineID == 1): # CHOOSE_MIN_SIZE_OVER_DDEG
        db = solver.Phase(varList, solver.CHOOSE_MIN_SIZE_OVER_DDEG, solver.ASSIGN_MIN_VALUE);
    elif (baselineID == 2):  # CHOOSE_FIRST_UNBOUND
        db = solver.Phase(varList, solver.CHOOSE_FIRST_UNBOUND, solver.ASSIGN_MIN_VALUE);
    elif (baselineID == 3): # Default strategy
        db = solver.DefaultPhase(varList)
    elif (baselineID == 4): # Random strategy
        db = solver.Phase(varList, solver.CHOOSE_RANDOM, solver.ASSIGN_MIN_VALUE);
    elif (baselineID == 5): # CHOOSE_MAX_SIZE
        db = solver.Phase(varList, solver.CHOOSE_MAX_SIZE, solver.ASSIGN_MIN_VALUE);
    elif (baselineID == 6):  # CHOOSE_MIN_SIZE_OVER_TDEG
        db = solver.Phase(varList, solver.CHOOSE_MIN_SIZE_OVER_TDEG, solver.ASSIGN_MIN_VALUE);

    searchLimit = solver.TimeLimit(solverTimeLimit) if useTimeLimit else solver.BranchesLimit(solverNodeLimit)
    solver.NewSearch(db, searchLimit)
    solver.setMasterDRL(masterDRL)
    solver.setSolverPhase(solver.TESTING);
    print("Baseline solver constructed.")
    return solver, varList, searchLimit